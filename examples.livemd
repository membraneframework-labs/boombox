# Boombox examples

```elixir
Logger.configure(level: :info)

# For ffmpeg and ffplay commands to work on Mac Livebook Desktop
System.put_env("PATH", "/opt/homebrew/bin:#{System.get_env("PATH")}")

Mix.install([{:boombox, path: __DIR__}, :kino, :nx, :exla, :bumblebee])

Nx.global_default_backend(EXLA.Backend)
```

## Boombox

```elixir
:inets.start()

:inets.start(:httpd,
  bind_address: ~c"localhost",
  port: 1234,
  document_root: ~c"#{__DIR__}/examples_assets",
  server_name: ~c"assets_server",
  server_root: "/tmp",
  erl_script_nocache: true
)
|> case do
  {:ok, _server} -> :ok
  {:error, {:already_started, _server}} -> :ok
end
```

```elixir
bbb_mp4_url =
  "https://raw.githubusercontent.com/membraneframework/static/gh-pages/samples/big-buck-bunny/bun10s.mp4"

bbb_mp4 = "#{__DIR__}/test/fixtures/bun10s.mp4"
out_dir = "#{__DIR__}/examples_outputs"
```

<!-- livebook:{"branch_parent_index":0} -->

## MP4 to WebRTC

To receive the stream, visit http://localhost:1234/stream_to_browser/index.html after running the cell below

```elixir
Boombox.run(input: bbb_mp4, output: {:webrtc, "ws://localhost:8830"})
```

<!-- livebook:{"branch_parent_index":0} -->

## MP4 via HTTP to WebRTC

To receive the stream, visit http://localhost:1234/stream_to_browser/index.html after running the cell below

```elixir
Boombox.run(input: bbb_mp4_url, output: {:webrtc, "ws://localhost:8830"})
```

<!-- livebook:{"branch_parent_index":0} -->

## WebRTC to MP4

To send the stream, visit http://localhost:1234/stream_from_browser/index.html

```elixir
Boombox.run(input: {:webrtc, "ws://localhost:8829"}, output: "#{out_dir}/webrtc_to_mp4.mp4")
```

```elixir
System.shell("ffplay #{out_dir}/webrtc_to_mp4.mp4")
```

<!-- livebook:{"branch_parent_index":0} -->

## WebRTC to WebRTC

Visit http://localhost:1234/stream_from_browser/index.html to send the stream and http://localhost:1234/stream_to_browser/index.html to receive it

```elixir
Boombox.run(input: {:webrtc, "ws://localhost:8829"}, output: {:webrtc, "ws://localhost:8830"})
```

<!-- livebook:{"branch_parent_index":0} -->

## MP4 to HLS

To receive the stream, visit http://localhost:1234/hls/stream.html after running the cell below

```elixir
Boombox.run(input: bbb_mp4, output: {:hls, "#{__DIR__}/examples_assets/hls/hls_output"})
```

<!-- livebook:{"branch_parent_index":0} -->

## RTMP to MP4

```elixir
uri = "rtmp://localhost:5432"

t =
  Task.async(fn ->
    Boombox.run(input: uri, output: "#{out_dir}/rtmp_to_mp4.mp4")
  end)

{_output, 0} = System.shell("ffmpeg -re -i #{bbb_mp4} -c copy -f flv #{uri}")

Task.await(t)
```

```elixir
System.shell("ffplay #{out_dir}/rtmp_to_mp4.mp4")
```

<!-- livebook:{"branch_parent_index":0} -->

## RTMP to WebRTC

To receive the stream, visit http://localhost:1234/stream_to_browser/index.html

```elixir
uri = "rtmp://localhost:5432"

t =
  Task.async(fn ->
    Boombox.run(input: uri, output: {:webrtc, "ws://localhost:8830"})
  end)

{_output, 0} = System.shell("ffmpeg -re -i #{bbb_mp4} -c copy -f flv #{uri}")

Task.await(t)
```

<!-- livebook:{"branch_parent_index":0} -->

## MP4 via WebRTC to MP4

```elixir
signaling = Membrane.WebRTC.SignalingChannel.new()

t =
  Task.async(fn ->
    Boombox.run(input: bbb_mp4, output: {:webrtc, signaling})
  end)

Boombox.run(input: {:webrtc, signaling}, output: "#{out_dir}/mp4_webrtc_mp4.mp4")

Task.await(t)
```

```elixir
System.shell("ffplay #{out_dir}/mp4_webrtc_mp4.mp4")
```

<!-- livebook:{"branch_parent_index":0} -->

## Speech to text

```elixir
{:ok, whisper} = Bumblebee.load_model({:hf, "openai/whisper-tiny"})
{:ok, featurizer} = Bumblebee.load_featurizer({:hf, "openai/whisper-tiny"})
{:ok, tokenizer} = Bumblebee.load_tokenizer({:hf, "openai/whisper-tiny"})
{:ok, generation_config} = Bumblebee.load_generation_config({:hf, "openai/whisper-tiny"})

serving =
  Bumblebee.Audio.speech_to_text_whisper(
    whisper,
    featurizer,
    tokenizer,
    generation_config,
    defn_options: [compiler: EXLA]
  )
```

To send the stream, visit http://localhost:1234/stream_from_browser/index.html

```elixir
Boombox.run(
  input: {:webrtc, "ws://localhost:8829"},
  output:
    {:stream,
     video: false, audio: :binary, audio_rate: 16_000, audio_channels: 1, audio_format: :f32le}
)
|> Stream.map(&Nx.from_binary(&1.payload, :f32))
|> Stream.chunk_every(200)
|> Enum.each(fn chunk ->
  batch = Nx.concatenate(chunk)

  Nx.Serving.run(serving, batch).chunks
  |> Enum.map_join(& &1.text)
  |> IO.puts()
end)
```
